#summary Architektur des Gesamtsystems (Big Picture)
#labels Phase-Design
= Designannahmen = 
 # Der Registrierungsserver sammelt CLientregistrierungen bis er maximal 4 beisammen hat, und startet mit diesen 4en ein Spiel
 # Bereits ab 2 Spieler kann ein Spieler einen Spielstart forcieren
 # Es existiert ein Masterserver und beliebig viele Slave Server. Die Server synchronisieren sich über Spread Messages
 # Die Spreadsynchronisation ist gleichzeit das Mittel für die Slaves herauszufinden, ob der Master noch am Leben ist
 # Antwortet derMaster nicht mehr, wird unter den Slaves eine Bully Election durchgeführt. Der Server mit der niedrigsten Server ID wird der neue Master
 # Neu hinzugefügte Server werden automatisch Slave, außer sie können sich nicht mit einem Master aufsynchronisieren --> Election!
 # Der Server erstellt PlayerAdapter Objekte und vergibt für die Player spielweit einheitlicher Player ID´s sowie eindeutige Playernamen

= Ablauf (grob) =
 # Ein Client lässt sich von einem Server ein neues systemweit einheitliches Spielerobjekt erzeugen
 # Mit diesem Spielerobjekt kann er sich auf einem Server nun zum Spielen registrieren (er gelangt dann in eine Warteschleife bis maximal 4 Spieler zusammenkommen, oder ein Mitspieler den Spielstart forciert)
 # Hat die Partie die geforderte Spieleranzahl (4) erreicht wird das Spiel gestartet. Dabei trennen die Clients ihre Verbindung zum Server und bauen untereinander eine Peer2Peer Verbindung auf
 # (Der Server teilt dem 1ten in der Runde noch mit, dass er nun mit seinem Zug dran ist) - nötig?
 # Jeder Client der am Zug ist, sendet seinen jeweiligen Zug multicast an jeden Mitspieler und wartet ab, ob der Zug vom jeweiligen CLient auch tatsächlich empfangen wurde
 # (antwortet ein Client nicht, wird an die anderen Mitspieler ausgesendet, dass ein Mitspieler nicht antwortet)
 # (Bei Erfolg) Anschließend beendet er seine "Transaktion" in dem er dem nächsten in der Runde mitteilt, dass er dran ist
 # Der nächste beginnt dann wieder wie oben.

= Ideen, Rahmenbedingungen und verwendbare Technologien =
 * Spread als Group-Communication Framework (ist gefordert)
 * Java RMI bietet mit der rmiregistry einen Naming Dienst. Ein Name-Lookup ist allerdings Host gebunden (d.h. man muss den Hostnamen auf dem rmiregistry läuft kennen --> Single-Point-of-Failure?)
 * RMI and JNDI binden bringt eventuell mehr Location Transparency? - http://download.oracle.com/javase/1.5.0/docs/guide/jndi/jndi-rmi.html
 * Clustering mit JBoss als Middleware - http://docs.jboss.org/jbossas/jboss4guide/r4/html/cluster.chapt.html
 * The Three Rings Project - [http://code.google.com/p/narya/ Narya], [http://code.google.com/p/vilya/ Vilya] 